# shambhala intro

<br />




Preface
---------

* convenient and secure transaction-signing scheme based on:

    - [Multisignature][multisig]
    - [Symmetric encryption][symenc]
    - [Web Storage]
    - In-browser [cross-origin communication]

* user is the only owner of the `"MASTER" MNEMONIC` with an optional `PASSPHRASE`
    (see [BIP-39]) and thus effectively he/she is **the only owner** of the
    `"MASTER" PRIVATE KEY` to his/her account, rendering him/her
    **the one and only person "in charge" of that account**

* opt-out from shambhala on user demand can't be prevented (owner of the
    `"MASTER" PRIVATE KEY` can do with his account whatever he/she desires to)

* [transaction XDR][transaction] and [signatures][signature] exchange is done
    using in-browser [cross-origin communication] preventing most of
    the threats listed in [Security Best Practices][SEP07sec] chapter of [SEP-0007]

* variants of onboarding / modes of operation:

    - **[Variant A]** - generates `"MASTER" MNEMONIC` for a user and allows
        him/her to choose a `PASSPHRASE`:

        - for the "first-time"/new users
        - and/or without the prior experience with _[stellar] network_
        - and/or without much knowledge about [crypto][cryptography] in general

    - **[Variant B]** - assumes that user already have an account on the
        _[stellar] network_:

        - for users already possesing account on the _[stellar] network_
        - and/or for experienced users with _[stellar] network_ knowledge
        - and/or possesing _[LedgerHQ] device_

<br />




Basic operations
------------------

Current set of basic operations is build on top of:

* [Stanford Javascript Crypto Library][sjcl]
* _node.js_ [crypto][node-crypto] module and [crypto-browserify] implementation
* [Tweet NaCl JavaScript][tweetnacl-js] library
* [scrypt-js] library
* [stellar JavaScript SDK][js-stellar-sdk]
* [redshift] library

For current implementation refer to [cryptops.js] and [txops.js] files.


### Crypto-related operations

* generation of a random value which can be used as a [salt]:

    ```javascript
    // random 256-bit value
    const salt32 = () => { ... }

    // random 512-bit value
    const salt64 = () => { ... }
    ```


* [password-based key-derivation][key-derivation]:

    ```javascript
    // pbkdf2, not too many iterations, 256-bit output
    const genKey = (pass, salt32) => { ... }

    // scrypt, 2^16 iterations, 512-bit output
    const deriveKey = (pass, salt64) => { ... }
    ```


* [symmetric][sym-key] [encryption]:

    ```javascript
    // two round xsalsa20-poly1305/aes encryption,
    // key composed of two 256-bit keys
    const encrypt = (key, secret) => { ... }
    ```


* [symmetric][sym-key] decryption:

    ```javascript
    // two round aes/xsalsa20-poly1305 decryption,
    // key composed of two 256-bit keys
    const decrypt = (key, ciphertext) => { ... }
    ```

* generation of [Universally Unique Identifier]:

    ```javascript
    // monotonic, 128-bit value:
    //     - 48 bits of miliseconds since epoch
    //     - 32 bits of truncated `sha256` sum of userAgent string
    //     - 48 random bits
    const genUUID = () => { ... }
    ```


### Transaction-related operations

* [transaction] inspection:

    ```javascript
    // decode relevant information from a given
    // `TransactionSignatureBase` XDR
    const inspectTSB = (tsbXDR) => { ... }
    ```

* [transaction] signing:

    ```javascript
    // sign given `TransactionSignatureBase` XDR using provided
    // stellar KeyPair and produce valid signature
    const signTSB = (tsbXDR, kp) => { ... }
    ```

<br />




Units
-------

* `KEYPAIR` - _StellarSDK.Keypair_ object
* `PASSPHRASE` - up to 100 characters long, alphanumeric word
* `G_MNEMONIC` - _genesis_ 24 word `"MASTER" MNEMONIC` with an optional
    `PASSPHRASE`, stored by _user_ (in a form of e.g. [paper wallet])
    and **known only to him/her**
* `G_PUBLIC` - user account number, stellar public key (G...),
    derived from `G_MNEMONIC`
* `GKP` - _genesis_ `KEYPAIR`, derived from `G_MNEMONIC`,
    comprised of `G_PUBLIC` and `"MASTER" PRIVATE KEY`
* `C_SECRET` - _client_ secret, stellar private key (S...)
* `C_PUBLIC` - _client_ public key (G...)
* `CKP` - _client_ `KEYPAIR`, (`C_PUBLIC` + `C_SECRET`)
* `S_SECRET` - _server_ secret, stellar private key (S...)
* `S_PUBLIC` - _server_ public key (G...)
* `SKP` - _server_ `KEYPAIR`, (`S_PUBLIC` + `S_SECRET`)
* `C_SALT`, `SALT_FOR_S` - random values, generated using [CSPRNG],
    stored using [Web Storage]
* `C_UUID` - client's [Universally Unique Identifier], stored using [Web Storage]
* `PIN` - minimum 5-digits secret (alphanumeric as option)
* `S_KEY` - [key][crypto-key] derived from `PIN` and `SALT_FOR_S`,
    used to encrypt/decrypt `ENC_SKP`
* `SALT_FOR_C` - random value, generated using [CSPRNG],
    not stored anywhere in plain form
* `C_PASSPHRASE` - [passphrase][crypto-passphrase] derived
    from `S_KEY` and `SALT_FOR_C`
* `C_KEY` - [key][crypto-key] derived from `C_PASSPHRASE` and `C_SALT`,
    used to encrypt/decrypt `ENC_CKP`
* `ENC_CKP` - `C_SECRET` encrypted using `C_KEY`, stored using [Web Storage]
* `ENC_SKP` - (`S_SECRET` + `SALT_FOR_C`) encrypted with `S_KEY`,
        stored on _server_
* `TX_PAYLOAD` - _TransactionSignaturePayload_ [XDR] (as defined in
    [StelarSDK][js-stellar-sdk])
* `C_SIGNATURE` - `TX_PAYLOAD` signed with `CKP`
* `S_SIGNATURE` - `TX_PAYLOAD` signed with `SKP`

<br />




Shambhala onboarding process _(draft)_
----------------------------------------

### 1. Initial state

* _user_:

    - no assumptions

* _client_:

    ```javascript
    let clientData = {
        G_PUBLIC: null,
        C_UUID: null,
        C_PUBLIC: null,
        C_SALT: null,
        ENC_CKP: null,
        SALT_FOR_S: null
    }
    ```

* _server_:

    ```javascript
    let serverData = {
        G_PUBLIC: null,
        C_UUID: null,
        S_PUBLIC: null,
        ENC_SKP: null
    }
    ```




### 2. **[Variant A]** - Account creation

_User_ doesn't have an account on _[stellar] network_.

* _client_:

    - [‚ùó] - generate `G_MNEMONIC` and present it to the _user_:

        ```javascript
        G_MNEMONIC = redshift.genMnemonic()
        ```

    - ask _user_ to create `PASSPHRASE` (can be empty)

    - [‚ùó] - create `GKP` (_path 0_):

        ```javascript
        GKP = func.compose(
            redshift.keypair,
            redshift.hexSeed
        )(G_MNEMONIC)
        ```

    - [üí•] - destroy `G_MNEMONIC`

    - extract `G_PUBLIC`, store it and send it to the _server_:

        ```javascript
        G_PUBLIC = GKP.publicKey()
        ```

    - generate `C_UUID`, store it and send it to the _server_:

        ```javascript
        C_UUID = cryptops.genUUID()
        ```

    - request funding from the _server_


* _server_:

    - receive `G_PUBLIC` and `C_UUID` from _client_ and store them

    - ask _[sfox service]_ (_friendbot_ on _[test net]_) to fund `G_PUBLIC`
        with minimal needed amount to perform appropriate [setOptions]
        operation assigning two new [ed25519] keys as signers




### 3. **[Variant B]** - Account association

_User_ already has a _[stellar] network_ account with funds.

* _client_:

    - ask _user_ to provide `G_PUBLIC`

    - generate `C_UUID`, store it and send it to the _server_:

        ```javascript
        C_UUID = cryptops.genUUID()
        ```

    - store `G_PUBLIC` and send it to the _server_

* _server_:

    - receive `G_PUBLIC` and `C_UUID` from _client_ and store them




### 4. Keys generation and storage

* _client_:

    - generate and store `SALT_FOR_S`:

        ```javascript
        SALT_FOR_S = salt32()
        ```

    -  ask _user_ to provide `PIN`
        (should be double-checked by two input fields)

    - compute `S_KEY`:

        ```javascript
        S_KEY = genKey(PIN, SALT_FOR_S)
        ```

    - send `S_KEY` to the _server_

    - [üí•] - destroy `PIN` and `S_KEY`


* _server_:

    - receive `S_KEY` from _client_

    - generate `S_SECRET`:

        ```javascript
        S_SECRET = StellarSDK.Keypair.random().secret()
        ```

    - generate `SALT_FOR_C`:

        ```javascript
        SALT_FOR_C = salt32()
        ```

    - compute and store `ENC_SKP`:

        ```javascript
        ENC_SKP = encrypt(S_KEY, S_SECRET + SALT_FOR_C)
        ```

    - compute `C_PASSPHRASE`:

        ```javascript
        C_PASSPHRASE = genKey(S_KEY, SALT_FOR_C)
        ```

    - extract `S_PUBLIC` from `S_SECRET`:

        ```javascript
        S_PUBLIC = StellarSDK.Keypair.fromSecret(S_SECRET).publicKey()
        ```

    - send `C_PASSPHRASE` and `S_PUBLIC` to _client_

    - [üí•] - destroy `S_KEY`, `S_SECRET`, `SALT_FOR_C` and `C_PASSPHRASE`


* _client_:

    - receive `C_PASSPHRASE` and `S_PUBLIC` from the _server_

    - generate and store `C_SALT`:

        ```javascript
        C_SALT = salt32()
        ```

    - compute `C_KEY`:

        ```javascript
        C_KEY = genKey(C_PASSPHRASE, C_SALT)
        ```

    - generate `C_SECRET`:

        ```javascript
        C_SECRET = StellarSDK.Keypair.random().secret()
        ```

    - compute and store `ENC_CKP`:

        ```javascript
        ENC_CKP = encrypt(C_KEY, C_SECRET)
        ```

    - extract `C_PUBLIC` from `C_SECRET`:

        ```javascript
        C_PUBLIC = StellarSDK.Keypair.fromSecret(C_SECRET).publicKey()
        ```

    - [üí•] - destroy `C_PASSPHRASE`, `C_KEY`, `C_SECRET`

    - present `C_PUBLIC` and `S_PUBLIC` to the _user_




### 5. Actual state

* _user_:

    - know his/her `G_MNEMONIC` and an optional `PASSPHRASE`
    - know his/her `PIN`
    - know his/her account public address - `G_PUBLIC`
    - is aware of `C_PUBLIC` and `S_PUBLIC`

* _client_:

    ```javascript
    let clientData = {
        G_PUBLIC: "GDVKSJYZ...",
        C_UUID: "01663f03...",
        C_PUBLIC: "GDNQLOS2...",
        C_SALT: "1f93a39461e87f2320071ad38362685...",
        ENC_CKP: "2rAAAey7/PNEaPpKNG8BtEZZOXFGaXLPDG...",
        SALT_FOR_S: "a65e8ff1b50bfc405828e7..."
    }
    ```


* _server_:

    ```javascript
    let serverData = {
        G_PUBLIC: "GDVKSJYZ...",
        C_UUID: "01663f03...",
        S_PUBLIC: "GASVBIEZ...",
        ENC_SKP: "AWY/D5eKB9FxqqS/wt8XDgfDy..."
    }
    ```




### 6. **[Variant A]** - Keys association

* _client_:

    - [‚ùó] - `GKP` is present in memory (_NOT_ in the persistent storage),
        as it was created in step two of **Account creation**.

    - `G_PUBLIC`, `C_PUBLIC` and `S_PUBLIC` are present in memory

    - construct `StellarSDK.Transaction` with an appropriate
        _setOptions_ operation:

        - `G_PUBLIC`, `C_PUBLIC`, `S_PUBLIC` _weights_
        - appropriate tresholds
        - `C_PUBLIC` and `S_PUBLIC` allowed for _multi-sig_

    - [‚ùó] - sign the transaction with `GKP`

    - [üí•] - destroy `GKP`


* _server_:

    - idle




### 7. **[Variant B]** - Keys association

* _client_:

    - `GKP` is not present in memory

    - `G_PUBLIC`, `C_PUBLIC` and `S_PUBLIC` are present in memory

    - construct `StellarSDK.Transaction` with an appropriate
        _setOptions_ operation:

        - `G_PUBLIC`, `C_PUBLIC`, `S_PUBLIC` _weights_
        - appropriate tresholds
        - `C_PUBLIC` and `S_PUBLIC` allowed for _multi-sig_

    - present `TX_PAYLOAD` to the _user_

    - if _user_ has [LedgerHQ], let him sign the transaction with it
        and send the signed transaction to the network

    - (alternatively): redirect to appropriate place in [Stellar Laboratory]


* _user_:

    - use computed `TX_PAYLOAD`, verify it, sign and send
        to network (with the usage of [LedgerHQ] and/or [Stellar Laboratory])

<br />




Shambhala transaction signing process _(draft)_
-------------------------------------------------

1. Initial state

* _user_:

    - know his/her `PIN`
    - has already associated `C_PUBLIC` and `S_PUBLIC`
        to his/her account in the process of onboarding

* _client_:

    - `G_PUBLIC` present in storage
    - `C_UUID` present in storage
    - `C_SALT` present in storage
    - `ENC_CKP` present in storage
    - `SALT_FOR_S` present in storage

* _server_:

    - `G_PUBLIC` present in storage
    - `C_UUID` present in storage
    - `ENC_SKP` present in storage




2. Transaction verification

* _client_:

    - decode `TX_PAYLOAD` and present to the _user_:

        - source account identifier
        - transaction fee
        - sequence number
        - time bounds
        - memo
        - operations




3. Transaction signing

* _client_:

    - ask _user_ to provide `PIN`

    - compute `S_KEY`:

        ```javascript
        S_KEY = genKey(PIN, SALT_FOR_S)
        ```

    - send `S_KEY` and `TX_PAYLOAD` to the _server_

    - [üí•] - destroy `PIN` and `S_KEY`


* _server_:

    - receive `S_KEY` and `TX_PAYLOAD` from _client_

    - extract `S_SECRET` and `SALT_FOR_C` by decrypting `ENC_SKP`:

        ```javascript
        S_SECRET + SALT_FOR_C = decrypt(S_KEY, ENC_SKP)
        ```

    - if extraction has failed it means that received `S_KEY` is invalid,
        so potential data breach occured on _client_ side or simply
        _user_ made a typo in `KEY`. In such scenario next steps
        are impossible, so the procedure has to be aborted, _failure
        counter_ has to be increased and _client_ has to be notified. Security
        precautions can be implemented in this step, for example after
        `3` failed attempts communication with this _client_ can be suspended
        for a longer period of time, etc.

    - generate `SKP`:

        ```javascript
        SKP = StellarSDK.Keypair.fromSecret(S_SECRET)
        ```

    - compute `S_SIGNATURE` by singing `TX_PAYLOAD` with `SKP`:

        ```javascript
        S_SIGNATURE = signTSB(TX_PAYLOAD, SKP)
        ```

    - [üí•] - destroy `SKP` and `S_SECRET`

    - compute `C_PASSPHRASE`:

        ```javascript
        C_PASSPHRASE = genKey(S_KEY, SALT_FOR_C)
        ```

    - send `C_PASSPHRASE` and `S_SIGNATURE` to _client_

    - [üí•] - destroy `S_KEY`, `SALT_FOR_C`, `C_PASSPHRASE`


* _client_:

    - receive `C_PASSPHRASE` and `S_SIGNATURE` from the _server_

    - compute `C_KEY`:

        ```javascript
        C_KEY = genKey(C_PASSPHRASE, C_SALT)
        ```

    - extract `C_SECRET` by decrypting `ENC_CKP`:

        ```javascript
        C_SECRET = decrypt(C_KEY, ENC_CKP)
        ```

    - generate `CKP`:

        ```javascript
        CKP = StellarSDK.Keypair.fromSecret(C_SECRET)
        ```

    - compute `C_SIGNATURE` by singing `TX_PAYLOAD` with `CKP`:

        ```javascript
         C_SIGNATURE = signTSB(TX_PAYLOAD, CKP)
         ```

    - [üí•] - destroy `CKP`, `C_SECRET`, `C_PASSPHRASE` and `C_KEY`

    - send `S_SIGNATURE` and `C_SIGNATURE` to the host application

<br />




Shambhala offboarding process _(idea)_
----------------------------------------

* User uses his `G_MNEMONIC` with `PASSPHRASE` to generate `GKP`
  and dissociate (with an appropriate `setOptions` operation) `C_PUBLIC`
  and `S_PUBLIC` keys from his account.

* User demands from shambhala (by calling appropriate API function)
  to delete `ENC_CKP` and `ENC_SKP` structures.

* Shambhala checks `signers` array on a `G_PUBLIC` account and if there are
  no `C_PUBLIC` and `S_PUBLIC` signers, then `ENC_CKP` and `ENC_SKP` can
  be safely deleted.

<br />




Notes
-------

* There's no way to enforce garbage collect process / shredding of
    memory remains in JavaScript. All places marked with [üí•] are currently
    hard (unknown) to achieve in JavaScript environment.

* After onboarding it is desirable to turn off the phone / computer
    for at least 30 (??) seconds to wipe out DRAM.

* Steps marked with [‚ùó] in the onboarding process are fragile from
    the security point of view. They are related to very sensitive
    areas - generation of `G_MNEMONIC`, access to and usage of `GKP` and
    `"MASTER" PRIVATE KEY`.

* There is always a tradeoff between security and convenience. Also,
    the more convenient a solution is (in the sense, that an user is not
    neccesarily an expert in a given field), the more chance there is
    that some degree of trust to a third party has to be calculated in.

* Safety of a described scheme is build on a following foundations:

    - there are two equally important keypairs (`CKP` and `SKP`), both
        stored in an encrypted form
    - _secret keys_ of both `CKP` and `SKP` are never leaving their
        environments (that is [Web Storage] in case of `CKP` and server-side
        database in case of `SKP`)
    - _user_ **knows** `PIN` and **has** `SALT_FOR_S`, which are the two
        neccessary ingredients to derive `S_KEY` needed to decrypt `SKP`,
        so in case of server-side database breach `SKP` is safe
    - decryption of `CKP` depends on _user_ **knowledge** (`PIN`) and,
        amongs other things, on element stored in **encrypted form** on server
        (`SALT_FOR_C`), so in case of client-side storage breach `CKP` is safe
    - if _user_ will loose a device with stored `CKP` or forget a `PIN` or
        simply want to cancel using _shambhala transaction-signing scheme_,
        his/her funds on _[stellar] network_ are safe, because he/she
        **knows** `G_MNEMONIC` with `PASSPHRASE` from which the **master key**
        can be derived
    - the same apply to the situation in which eventual server-side data loss
        occurs - **master key** is in the posession of a _user_, so funds
        on the stellar account are safe and accessible

* Strong emphasis has to be put on all security considerations related to
    onboarding process in **[Variant A]**.




[multisig]: https://www.stellar.org/developers/guides/concepts/multi-sig.html
[symenc]: https://en.wikipedia.org/wiki/Symmetric-key_algorithm
[cross-origin communication]: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage
[BIP-39]: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
[SEP-0007]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0007.md
[signature]: https://www.stellar.org/developers/guides/get-started/transactions.html#send-payments
[SEP07sec]: https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0007.md#security-best-practices-for-compliance-with-this-sep
[stellar]: https://www.stellar.org/
[cryptography]: https://en.wikipedia.org/wiki/Cryptography
[LedgerHQ]: https://www.ledger.fr/
[sjcl]: https://bitwiseshiftleft.github.io/sjcl/
[node-crypto]: https://nodejs.org/api/crypto.html
[tweetnacl-js]: https://tweetnacl.js.org/
[scrypt-js]: https://www.npmjs.com/package/scrypt-js
[crypto-browserify]: https://github.com/crypto-browserify/crypto-browserify
[js-stellar-sdk]: https://stellar.github.io/js-stellar-sdk/
[redshift]: https://www.npmjs.com/package/@stellar-fox/redshift
[cryptops.js]: ../src/cryptops.js
[txops.js]: ../src/txops.js
[salt]: https://en.wikipedia.org/wiki/Salt_(cryptography)
[paper wallet]: https://en.bitcoin.it/wiki/Paper_wallet
[key-derivation]: https://en.wikipedia.org/wiki/Key_derivation_function
[encryption]: https://en.wikipedia.org/wiki/Encryption
[sym-key]: https://en.wikipedia.org/wiki/Symmetric-key_algorithm
[Universally Unique Identifier]: https://en.wikipedia.org/wiki/Universally_unique_identifier
[transaction]: https://www.stellar.org/developers/guides/concepts/transactions.html
[CSPRNG]: https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator
[Web Storage]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API
[crypto-key]: https://en.wikipedia.org/wiki/Key_(cryptography)
[XDR]: https://www.stellar.org/developers/guides/concepts/xdr.html
[crypto-passphrase]: https://en.wikipedia.org/wiki/Passphrase
[Stellar Laboratory]: https://www.stellar.org/laboratory/
[test net]: https://github.com/stellar/docs/blob/master/guides/concepts/test-net.md
[sfox service]: https://github.com/stellar-fox/deneb
[setOptions]: https://stellar.github.io/js-stellar-sdk/Operation.html#.setOptions
[ed25519]: https://ed25519.cr.yp.to/
